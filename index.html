<!DOCTYPE html>
<html>
<head>
<title>Grylos</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script src="Markdown.Converter.js"></script>
<script src="Markdown.Extra.js"></script>
<script src="jquery-2.1.4.min.js"></script>
<link rel="stylesheet" href="highlight/styles/default.css">
<script src="highlight/highlight.pack.js"></script>
<script src="MathJax-master/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="markdown.js"></script>
<link rel="stylesheet" href="pure-min.css">
<link rel="stylesheet" href="markdown.css">
</head>
<body>
    <div style = "font-size:115%">
       <div class="markdown">
# Introduction {#introduction}

**Grylos** is a programming framework and a compiler that was build with the purpose of making decentralized programming easier. It
is part of the software that will be used by [ryaki](http://ryaki.org), an organization that aims to build p2p productive processes,
like Uber but with an emphasis on Democracy above all other
[properties](http://ryaki-org.blogspot.gr/2015/10/it-is-about-democracy-not-economic.html).

## Automation Challenges {#Automation_Challenges}

The rise of automation and the emergence of p2p production processes has introduced new requirements for software both technical and
ethical.

The automation of production processes with the use of computers makes it more difficult for people to understand why each
production choice is made. People have to do what the program tells them to do. This is already true for companies, an employee
doesn't know why he does something but automation has the potential to determine more parts of our life.  Grylos tries to alleviate
this problem by requesting that all p2p automation software use free software licenses(GPL).  Secondly, its goal is to make these
software easier to read. The end goal is that any person whose life is automated by software should be able to understand the
software code and be able to change it. 

To achieve those goals, grylos implements the below characteristics:

* It uses [literate programming](https://en.wikipedia.org/wiki/Literate_programming). Each program is a book that contain pieces of
code. The book explains the motivation behind the code.
* It has a very powerful metaprgramming framework that allows for the creation of models and the generation of code from them.
* It uses visual graph representations for programming distributed applications.

## Distributed systems Cost of Developing {#Distributed_Systems_Cost}

Apart from the ethical requirements of automating p2p processes, there are technical problems as well. Writing distributed
applications is very difficult. Thus it requires a considerable amount of capital for them to be built. Investors have the tendency
of controlling whatever they invest on. Uber for example has created a very good p2p application but the control of that application
has resulted in making a fortune while the people that work as taxi drivers earning very little. Thus, if we want to create a myriad
of p2p processes that are controlled democraticly, we need to decrease the cost of building them.

To reduce the cost of Developing, grylos has te below characteristics:

* It is reactive and functional.  It promotes programming without side effects. Side effects, when present, are explicitly handled.
* It promotes programming without state. If state is present, it has rules that make distributed programming safe.
Those rules are checked by the compiler.
  * The visual graph representation consists of a number of functions and their composition. There are no loops.
The graph is a series of statements and the program needs to guarantee their logical consistency.

example: 
``` 
f(x) = 2x 
g(x) = 5 - x

f->g

```

When x = 2, f = 4, thus g must be 1, otherwise the program would be logically inconsistent.  Being similar to declarative
programming, it allows for easier reasoning than imperative programming with state.

* It makes stateful distributed programming easy.  Grylos uses the graph visualization to define state machines. The code follows
the logic of the application.
* State machine code is generated by the compiler. This is the most important feature of grylos because p2p processes are stateful. 
//TODO update this when I finish implementing the reamining features.
  * It is easy to split state machines and create a hierarchy of them. That is important because p2p processes and group
  * organizations are fractal.

* It introduces a metaprogramming framework, [protein](https://github.com/xekoukou/protein). This allows people to make abstractions
of the p2p processes. It allows them to create models of them.  Models compresses information about the p2p processes into the
important parts and that allows people to better understand them and reason about.  It allows them to create a multitude of
different p2p processes using the template system of the model and thus it reduces the cost of programming.

## Additional Properties of Grylos {#additional_properties_of_grylos}

* **Order of execution**: Grylos only guarantees the logical consistency of function composition. The order of execution can not be
determined beforehand. 
* Grylos code is **implicitly concurrent** and **explicitly parallel**. The same function, if given two sets
of arguments, can execute concurrently. Two subgraphs that do not depend to each other can executed in parallel.  Grylos uses
**multi-level visual graph representations** that allow people to organize code thematically.

# Description {#Description}

Grylos uses graph visualizations to describe the composition of different functions, as well as to define special properties that
edges and nodes of the graph have.

## Graphs and nodes {#Graphs_and_Nodes}

Each program consists of nodes. A node can either contain code or a graph that contains nodes. We call them **code nodes** and
**graph nodes** respectively. 

A graph is **directed** and **acyclic**. Each node requires all inputs to execute and produce an output, like a normal function. 

//TODO These will probably change in the future.

Nodes can have these properties:

* Parallelized/Concurrent: This node should be executed in a different thread.
* Impure/User interaction: The node represents an interaction with a user and that makes the node impure, or we need to interact
with computers whose internal working are not known.
* safe/pure: The graph node contains impure code, but the protocol itself guarantees that the graph node is pure. By tagging the
graph node as pure we tell the compiler that it should be treated as safe/pure. 
* restriction: The node checks the input if it has specific properties. If not it exits, else it continues its computation. This
can be thought as a domain restriction. For clarity's sake we allow this node to have the ability to exit, thus have side-effects.

Keep in mind that restrictions should be prohibited in a distributed environment. The application should never have to halt on a
specific input.

Edges can have these properties:

* mutable: The output is mutable but must also abide by restrictions. The mutable variable can only be passed to only one node in a
different thread. 
* lossless: This output requires that it is computed for all input sent to the node.
* Ordered: This output requires that it is computed in the order of the input received. FIFO.
* historical: This output depends on previous inputs of the node. It needs to be ordered and lossless.
* passive: This output doesn't propagate the execution. It waits to be used when events from other parts of the graph are triggered.
* saved: The output is saved into a database/file.
* timed out: This output returns nothing if the timeout passes without data received. This introduces impurity because the
result depends on the execution timings.
* ??dynamic: Here dynamic functions/subgraphs can attach to.


## Local functions {#Local_functions}

Each graph has also 3 types of functions that can be used by the contained nodes and recursively by all the contained nodes of the
graph nodes.

* reusable functions: Functions that can be used multiple times. 
* single use functions: Functions that are used only once from a code node of this graph. Since there can be no if-statements in 
the graph, paths express functional composition, single_use functions are used inside code nodes in if statements.
* dynamic functions: Functions that are plugged into the graph at runtime. In this way we mutate the graph at runtime.

We will all call them **local functions**.

## Continuation style of programming and distributed closed systems. {#Continuation_style}

In grylos, all interactions of distributed parts/servers are expressed with a directed edge in a graph tha represents that
interaction.

Grylos models complete distributed systems. All applications's code is part of the same source code. Interacting with the outside
world happens in 2 cases:

* Software and apis we do not control and thus we can not integrate with the remaining source code.
* The interactions of users with the software itself.

Both interactions introduce impurity because there are factors that can not be modeled and affect the outcome of the computation. In
the first case, because the working of the software is not known to us. In the second case because we do not simulate the physics
that determine the actions of humans or the results of sensors.

Since interacting with other software can be avoided, we say that grylos is a platform for the generation of distributed closed
systems, closed because all software parts of the distributed system are in the same source code/generated by the same compiler.

### Functional Homeomorphism and Impurity {#Functional_Homeomorhism}

In mathematics, two functions are equal if for the same input, they give the same output.

Grylos compiles closed distributed systems. What this means is that the root/main function gets 1 as input and returns 0. 
Thus one could then go and say that all programs written in Grylos are homeomorphic to the trivial one of returning 0.

As we know from the previous section, all our programs are impure because we want them to be meaningful to the outside world.
Thus, functional homeomorphism can not apply here. It can only apply to sections of our program that is pure. Grylos tries to
separate those parts from the impure parts.

### Handling impurity {#Handling_Impurity}

Since inpure parts of the code, places where users interact with the software, give different outputs on the same inputs. We cannot
test those parts of the code. We can though add software that simulates the users in a deterministic way. That way, impurities turn
into purities and we can test the code that previously was inpure as if it is pure. 
 
## Subgraph Code Plurariry and Code evolution. {#Subgraph_Code_Plurarity_Code_Evolution}

//TODO Implement this and rewrite this section.

Subgraphs of our distributed system can be implemented in multiple different ways but at the same time they must obey the
resitrictions of the global graph. This way we can allow our distributed system to have plurarity in the way subalgorithms are
handled. This can allow new algorithms to be tested and if better than others to replace the previous algorithms naturally, without
requiring a restart of the system.

//TODO This has not been implemented yet.

At the same time our source code needs to change. We have mananged to make our source code purely functional but any transition from
one git commit to another is not functional. We need to consider time and git commits as a varriable that when explicitly taken into
account make the system functional even when the code changes.

//TODO This needs to be removed. It contains some useful information that might need to be kept though.

State machines are used in grylos to allow for a continuation style of programming in distributed applications. The state is simply
the position in the graph that computations will follow as soon as a network response is received.

* A state machine has a name that works as an unique id in the application.  A state machine transition might allow the handling of
* the lower level state machine to be handled by other servers. That transition should provide a name that acts as a unique id for
* that handling.  The server should be able to add servers as eligible to handle the lower state machine.  Grylos should be able to
* provide an optional security mechanism that only accepts inputs that have been handled by those servers. (with a signature
* mechanism).


# Compiler Overview {#Compiler_Overview}

## Modularity and recursive execution. {#Modularity_and_Recursive_Execution}

Tests can be applied at each node. Because of that, the code for that node will need to be generated seperately from the main
program. That forces our compilation and code generation to be modular. 

The process of joining nodes to compile graph nodes and ultimately the program is as follows:
* If a node is a code node, we find all the dependencies it has with reusable or single use functions. (TODO dynamic?). We compile
them and then compile the code node.  If a node is a graph node, we compile all containing nodes and then compile the graph node.

Please note that local functions have also local functions inside them. Also it is important to note these implementation details:
* If multiple nodes depend on one reusable function, only one compilation should happen.(check following section). 
* For multiple levels of graphs to join, some requirements need to be met: 
  * All inputs of a lower graph need to be provided by the previous graph.  
  * All outputs of the higher graph need to have a corresponding node that provides that output.  On the top level, there
* should be no inputs/outputs or inputs/outputs(in case it is a local function/aka library) that have been explicitly defined.

## Recompilation {#Recompilation}

At the same time we want our compiler to know which parts of the code changed and only recompile those pieces. 

There are 2 cases:

* a node changes: This node needs to be recompiled and all the graphs that recursively contain it. (unless we use the inline
key word, in which case if its input/output and name do not change, then only need to compilte itself.)
* A reusable or single use function changes: All nodes that are at lower levels need to be compiled if they depend on this 
function. (thus we need to keep track of those dependencies). The graph that contains this function and recursively all higher 
graphs need to recompile , similarly to when a node changes.

Certainly, the compiler needs to keep track of changes in the nodes. Thus it needs to keep a list of time of last change of a node
that was compiled and check it with the current time of last change. 

## Two steps of compilation {#Two_Steps_of_Compilation}

There are two steps in the compilation.

The first compilation has to do with generating the information required for the second step as well as provide checks that all the
information is correct, that the restrictions we have put have been upheld are correct.  (Some restrictions might need the complete
information from all the nodes to be checked and thus cannot be modular (?))


//TODO Find a solution.
The second process deals with generating the code based on the information provided by the first process. In this case as well, we
can not be modular. There are multiple reasons for this:

* The lossless property progates backward.  
* The code needed for the reactive scheduler needs to be modular. (maybe we can do this). In any case, the final step of joining
all the modular parts will need to happen at the end.

# Testing {#Testing}

For testing we will use these functions:

```javascript test
function is_object(obj) {
  return obj === Object(obj);
}

function are_var_equal(var1,var2) {
  if(Array.isArray(var1) && Array.isArray(var2)) {
    return are_arrays_equal(var1,var2);
  }
  if(is_object(var1) && is_object(var2)) {
    return are_objects_equal(var1,var2);
  }
  if(!is_object(var1) && !is_object(var2)) {
    return var1 == var2;
  }
  return false;
}

function are_arrays_equal(ar1,ar2) {
  if(ar1.length != ar2.length) {
    return false;
  }
  for(var index = 0; index < ar1.length; index++) {
    var el1 = ar1[index];
    el2 = ar2[index]; 
    if(!are_var_equal(el1,el2)) {
      return false;
    }
  };
  return true;
}

function are_objects_equal(obj1,obj2) {
  var keys = Object.keys(obj1);
  for(var index = 0; index < keys.length; index++) {
    var key = keys[index];
    if(!(key in obj2)) {
      return false;
    }
    if(!are_var_equal(obj1[key],obj2[key])) {
      return false;
    }
  };
  return true;
}

function assert(var1, var2, msg) {
  if(!are_var_equal(var1,var2)) {
    debug(var1);
    debug(var2);
    throw new Error(msg);
  }
}

function debug(data) {
  process.stderr.write(JSON.stringify(data) + "\n");
}

function error(data) {
  process.stderr.write(JSON.stringify(data) + "\n");
}
```

# Module Dependencies {#Module_Dependencies}

//TODO this needs to be removed in the final program and put in the corrent place.

```javascript
var fs = require('fs');
var execSync = require('child_process').execSync;
```

# Generate graph xml from mr file {#Generate_Graph_xml_from_mr_file}

A graph node contains all the data about the graph in its xml file. The graph itself could be created through a nice gui or it could
be provided in a simple text file with an '.mr' extension.

In both cases, the data of the graph need to be inserted into the XML file. This is the purpose of this graph node:

//TODO Explain the format of the graph tag.

```mr
./output("./temp/generate_graph_xml_from_mr_file.mr")
./dots(1)
parse_mr_file  check_node_properties:r  check_same_output_name:r    insert_graph_content_to_xml_files
     |-(graph)-------|-----(graph_v1)--------|-----(graph_v2)------------------|
./dots(-1)
```

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file.xml")
./dots(1)
--%gt
%ltroot%gt
%ltinfo%gt
%ltname%gtgenerate_xml_from_mr_file%lt/name%gt
%lt/info%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

## Parse .mr file {#Parse_mr_file}

The syntax of the .mr file is as follows:

* Function names
    *  are strings without spaces that do not contain parenthesis.
    * can contain 'single character' properties which are seperated from the name with a colon ":".
    * can contain a name that represents the server type responsible for this node, seperated by a secondary ":".
* Below each function name, there is only one pipe sympol "|" and below that pipe sympol more can follow.
* A Path
    * is a series of minuses "-" that connect one pipe of a function with another, the left side representing the
 output of a variable and the right the input. Let us call this a *path*.
    * can go down one line with a backslash "\" and up with a forward slash "/".
    * **must** contain the name of the variable contained in parentheses.
    * can have properties that are single characters that are separated from the name with a colon.
    * can contain a name that represents the type of connection between 2 distributed parts, separated by a secondary colon ":".

In this graph node, we will parse the .mr file and we will create a  graph object of its data.

```mr
./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file.mr")
./dots(1)
load_mr_file:r find_function_names:r     find_end_points:r            path_finding:r         build_graph
  |            |-----------(function_names)-------|--------(end_points)---------|-------(paths)-----|
  |            |------------(function_names)--------------------------------------------------------|
  |-(lines)----|                           find_end_points                    
  |-(lines)-------------------------------------|                         path_finding
  |-(lines)-------------------------------------------------------------------|
./dots(-1)
```

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file.xml")
./dots(1)
--%gt
%ltroot%gt
%ltinfo%gt
%ltname%gtparse_mr_file%lt/name%gt
%lt/info%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

## load mr file {#load_mr_file}

It loads the mr_file and splits it into lines.

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/load_mr_file.xml")
./dots(1)
--%gt
%ltroot%gt
%ltinfo%gt
%ltname%gt load_mr_file%lt/name%gt
%lt/info%gt
%ltinputs%gt
%ltinput name="mr_file" side-effect="true"%gt
    %ltdescription%gtIt is provided the mr file of the mr_file_path.%lt/description%gt
%lt/input%gt
%ltinput name="mr_file_path"%gt
%lt/input%gt
%lt/inputs%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

```javascript
//.dots(-1)("./temp/generate_graph_xml_from_mr_file/parse_mr_file/load_mr_file.js")
//./dots(1)
function load_mr_file(file_path) {
var lines;
////
var file;
try {
  file = fs.readFileSync(file_path,"utf8");
} catch(e) {
  process.exit(4);
}
lines = file.split("\n");
////
return lines;  
}
//.dots(-1)
```

```javascript test
assert(load_mr_file("./tests/generate_graph_xml_from_mr_file/parse_mr_file/load_mr_file/1.mr"), ["line1","line2",""],"load_mr_file 1 test Failed");
```

## Find function names {#Find_function_names}

Returns the function names of the nodes and their position inside the mr file.

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names.xml")
./dots(1)
--%gt
%ltroot%gt
%ltinfo%gt
%ltname%gt find_function_names %lt/name%gt
%lt/info%gt
%ltinputs%gt
%ltinput name="mr_file_path"/%gt
%lt/inputs%gt
%ltoutputs%gt
%lt/outputs%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

```javascript
//./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names.js")
//./dots(1)

function find_function_names(lines,mr_file_path) {
var function_names;
////////////////////////
function_names = [];

var y = 0;
while (y < lines.length) {
var x = 0;
var line = lines[y];
while (x < line.length) {
    var xar = line.charAt(x);
    //find all non whitespace strings
    if (xar != " ") {
	var string = line.substring(x).split(" ", 1)[0];
	//check that they only have alphanumeric or _ characters
	var alphanum = string.match(/^[a-z_:0-9]+$/i);
	if (alphanum) {
	    var value = alphanum[0].split(":", 2);
	    var function_name = {
		x: x,
		y: y,
		fn_name: value[0],
		properties: {}
	    };
	    if (value.length > 1) {
		for (var i = 0; i < value[1].length; i++) {
		    var xar = value[1].charAt(i);
                    switch (xar) {
                      case "c": {
			function_name.properties.concurrent = true;
                        break;
                      }
                      case "i": {
		        function_name.properties.impure = true;
                        break;
                      }
                      case "p": {
		        function_name.properties.pure = true;
                        break;
                      }
                      case "r": {
		        function_name.properties.restriction = true;
                        break;
                      }
                      default: {
	        	error("Error: There is no option '" + xar + "' for a function");
			error("File: " + mr_file_path);
			error("Function Name: " + value[0]);
			process.exit(1);
                      }
                    }
		}
	    }
	    //store them
	    function_names.push(function_name);
	}
	x = x + string.length - 1;
    }
    x++;
}
y++;
}
return function_names;
}
//./dots(-1)
```

```javascript test
assert(find_function_names(load_mr_file("./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names/1.mr"),"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names/1.mr"),
[{'fn_name':'hello','x':0,'y':0,properties:{'concurrent':true,'restriction':true}},{'fn_name':'world','x':18,'y':0,properties:{}},{'fn_name':'Hi','x':0,'y':3,properties:{'impure':true}},{'fn_name':'there','x':11,'y':3,properties:{'concurrent':true,'restriction':true,'pure':true}}],"find function_names 1 test Failed");

assert(find_function_names(load_mr_file("./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names/2.mr"),"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names/2.mr"),"error 1","find_function_names 2 test Failed");
```

## Find end points {#Find_end_points}

It returns the position of all the end_points with the function they belong to. 

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points.xml")
./dots(1)
--%gt
%ltroot%gt
    %ltinfo%gt
        %ltname%gt find_end_points %lt/name%gt
    %lt/info%gt
    %ltinputs%gt
        %ltinput name="mr_file_path"/%gt
    %lt/inputs%gt
    %ltoutputs%gt
    %lt/outputs%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

```javascript
//./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points.js")
//./dots(1)
function find_end_points(lines, function_names, mr_file_path) {
    var end_points;
    ////////////////////
    end_points = {};

for(var i = 0; i < function_names.length; i++) {
    var fn = function_names[i];

    if (fn.y + 1 == lines.length) {
      error("Error: There is a function that isn't connected to another function.");
      error("File: " + mr_file_path);
      error("Function Name: " + fn.fn_name);
      process.exit(2);
    }

    var y = fn.y + 1;
    var line = lines[y];
    var x = fn.x;
    var once = 0;
    while ((x < fn.x + fn.fn_name.length) && (x < line.length)) {
        var xar = line.charAt(x);

        if (xar == "|") {
            if (!end_points[y]) {
                end_points[y] = {};
            }
            end_points[y][x] =
                fn.fn_name;

            y++;
            if (y >= lines.length) {
                break;
            }
            line = lines[y];
            var once = 1;

        } else {
            if (once) {
                break;
            }
            x++;
        }
    }

    if (once == 0) {
      error("Error: There is a function that isn't connected to another function.");
      error("File: " + mr_file_path);
      error("Function Name: " + fn.fn_name);
      process.exit(3);
    }

};

//./dots(-1)
  return end_points;
}
```

```javascript test
var test_lines = load_mr_file("./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/1.mr");
assert(find_end_points(test_lines, find_function_names(test_lines,"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/1.mr"),"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/1.mr"), {'1':{'2':'hello','18':'world'},'4':{'0':'Hi','12':'there'}},"find end points test 1 Failed");

var test_lines = load_mr_file("./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/2.mr");
assert(find_end_points(test_lines, find_function_names(test_lines,"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/2.mr"),"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/2.mr"), "error 3","find end points test 2 Failed");
```


## Path finding {#Path_finding}
        
It finds all the paths of the graphs.

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/path_finding.xml")
./dots(1)
--%gt
%ltroot%gt
    %ltinfo%gt
        %ltname%gt path_finding %lt/name%gt
    %lt/info%gt
    %ltinputs%gt
        %ltinput name="mr_file_path"/%gt
    %lt/inputs%gt
    %ltoutputs%gt
    %lt/outputs%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

```javascript
//.dots(-1)("./temp/generate_graph_xml_from_mr_file/parse_mr_file/path_finding.js")
//./dots(1)
function path_finding(lines, end_points, function_names, mr_file_path) {
    var paths;
    ///////////////////////////
    paths = [];

    var y_keys = Object.keys(end_points);
    for(var i = 0; i < y_keys.length; i++) {
        var y_key = y_keys[i];
        var x_keys = Object.keys(end_points[y_key]);
        for(var j = 0; j < x_keys.length; j++) {
            var x_key = x_keys[j];
            var path = {
                y: +y_key,
                x: +x_key,
                origin_fn_name: end_points[y_key][x_key]
            };
            while (true) {
                //Checking which way to go next.
                //up
                var up = 0;
                var y = path.y - 1;
                var x = path.x;
                var line = lines[y];
                var xar;
                if (x < line.length) {
                    xar = line.charAt(x);
                    if (xar == "/") {
                        up = 1;
                    }
                }

                //down
                var down = 0;
                y = path.y + 1;
                x = path.x;
                if (y < lines.length) {
                    line = lines[y];
                    if (x < line.length) {
                        xar = line.charAt(x);
                        if (xar == "\\") {
                            down = 1;
                        }
                    }
                }



                var right = 0;
                y = path.y;
                x = path.x + 1;
                line = lines[y];
                if (x < line.length) {
                    xar = line.charAt(x);
                    if ((xar == "-") || (xar == "|") || (xar == "(")) {
                        right = 1;
                    }
                }

                //Making sure there are no paths without ending.
                if (!(up || down || right)) {
                    line = lines[path.y];
                    xar = line.charAt(path.x);
                    if (xar != "|") {
                        error("\nError: mr_file:" + mr_file_path + ".mr(line: " + path.y + "," + "position: " + path.x + ")");
                        error("A path with no end.");
                        process.exit(5);
                    } else {
                        break;
                    }
                }
                //Maling sure paths have only one possible direction to go.
                if ((up && down) || (up && right) || (down && right)) {
                    error("\nError: mr_file:" + mr_file_path + ".mr(line: " + path.y + "," + "position: " + path.x + ")");
                    error("Multiple paths detected.");
                    process.exit(6);
                }
                //Moving forward.
                if (up) {
                    path.y = path.y - 1;
                    path.x = path.x;
                }

                if (down) {
                    path.y = path.y + 1;
                    path.x = path.x;

                }

                if (right) {
                    path.y = path.y;
                    path.x = path.x + 1;


                    line = lines[path.y];
                    xar = line.charAt(path.x);
                    //Checking if this is a value name declaration
                    if (xar == "(") {
                        var array = line.substring(path.x + 1).split("-");
                        if (array[0][array[0].length - 1] != ")") {

                            error("\nError: mr_file:" + mr_file_path + ".mr(line: " + path.y + "," + "position: " + path.x + ")");
                            error("There is a missing ')'.");
                            process.exit(7);
                        } else {
                            array[0] = array[0].slice(0,-1);
                            var temp = array[0].split(":");
                            switch (temp.length) {
                              case 3:{
                                path.net_name = temp[2];
                              }
                              case 2:{
                                for (var i = 0; i < temp[1].length; i++) {
                                    var each = temp[1].charAt(i);
                                    switch (each) {
                                      case "p": {
                                        path.passive = true;
                                        break;
                                      } 
                                      case "d": {
                                        path.dynamic = true;
                                        break;
                                      }
                                      case "h": {
                                        path.historical = true;
                                        break;
                                      }
                                      case "m": {
                                        path.mutable = true;
                                        break;
                                      }
                                      case "s": {
                                        path.saved = true;
                                        break;
                                      }
                                      case "t": {
                                        path.timed_out = true;
                                        break;
                                      }
                                      case "l": {
                                        path.lossless = true;
                                        break;
                                      }
                                      case "o": {
                                        path.ordered = true;
                                        break;
                                      }
                                      default: {
                                        error("\nError: mr_file:" + mr_file_path + ".mr(line: " + path.y + "," + "position: " + path.x + ")");
                                        error("Wrong option type.");
                                        process.exit(8);
                                      }
                                  }
                                }
                              }
                              case 1:{
                                path.vname = temp[0];
                              }
                            }
                            path.x = path.x + array[0].length + 2;
                        }


                    } else {
                        //Checking if this is the end of the path.
                        if (xar == "|") {

                            path.end_fn_name = end_points[path.y][path.x];
                            //Remove unnecessary properties and store path.
                            delete path.x;
                            delete path.y;
                            paths.push(path);
                            break;

                        }
                    }
                }

            }
        }
    }

    return paths;
}
//./dots(-1)
```

```javascript test
var mr_file_path = "./tests/generate_graph_xml_from_mr_file/parse_mr_file/path_finding/1.mr";
var lines = load_mr_file(mr_file_path);
var function_names = find_function_names(lines,mr_file_path);
var end_points = find_end_points(lines, function_names,mr_file_path)
assert(path_finding(lines, end_points, function_names,mr_file_path
),[{"origin_fn_name":"hello","net_name":"net","vname":"var_name","end_fn_name":"world"},{"origin_fn_name":"Hi","mutable":true,"passive":true,"vname":"y","end_fn_name":"there"}],"path finding test 1 Failed");

var mr_file_path = "./tests/generate_graph_xml_from_mr_file/parse_mr_file/path_finding/2.mr";
var lines = load_mr_file(mr_file_path);
var function_names = find_function_names(lines,mr_file_path);
var end_points = find_end_points(lines, function_names,mr_file_path)
assert(path_finding(lines, end_points, function_names,mr_file_path
), "error 5","path finding test 2 Failed");

var mr_file_path = "./tests/generate_graph_xml_from_mr_file/parse_mr_file/path_finding/3.mr";
var lines = load_mr_file(mr_file_path);
var function_names = find_function_names(lines,mr_file_path);
var end_points = find_end_points(lines, function_names,mr_file_path)
assert(path_finding(lines, end_points, function_names,mr_file_path
), "error 6","path finding test 3 Failed");

var mr_file_path = "./tests/generate_graph_xml_from_mr_file/parse_mr_file/path_finding/4.mr";
var lines = load_mr_file(mr_file_path);
var function_names = find_function_names(lines,mr_file_path);
var end_points = find_end_points(lines, function_names,mr_file_path)
assert(path_finding(lines, end_points, function_names,mr_file_path
), "error 7","path finding test 4 Failed");

var mr_file_path = "./tests/generate_graph_xml_from_mr_file/parse_mr_file/path_finding/5.mr";
var lines = load_mr_file(mr_file_path);
var function_names = find_function_names(lines,mr_file_path);
var end_points = find_end_points(lines, function_names,mr_file_path)
assert(path_finding(lines, end_points, function_names,mr_file_path
), "error 8","path finding test 5 Failed");
```

## Build graph {#build_graph}

It creates an object representation of the graph that is in the mr files.

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/build_graph.xml")
./dots(1)
--%gt
%ltroot%gt
    %ltinfo%gt
        %ltname%gt build_graph %lt/name%gt
    %lt/info%gt
    %ltoutputs%gt
        %ltoutput name="graphs"%gt
            %ltdescription%gt An object representation of the graph that is in the mr files. %lt/description%gt
        %lt/output%gt
    %lt/outputs%gt
    %ltinputs%gt
        %ltinput name="mr_file_paths"/%gt
        
        
    %ltinput generated="true" name="function_names"/%gt%ltinput generated="true" name="gpaths"/%gt%lt/inputs%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt

```




       </div>
    </div>
</body>
</html>
