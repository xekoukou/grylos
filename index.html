<!DOCTYPE html>
<html>
<head>
<title>Metareact</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script src="Markdown.Converter.js"></script>
<script src="Markdown.Extra.js"></script>
<script src="jquery-2.1.4.min.js"></script>
<link rel="stylesheet" href="highlight/styles/default.css">
<script src="highlight/highlight.pack.js"></script>
<script src="MathJax-master/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="markdown.js"></script>
<link rel="stylesheet" href="pure-min.css">
<link rel="stylesheet" href="markdown.css">
</head>
<body>
    <div style = "font-size:115%">
       <div class="markdown">
# Introduction {#introduction}

**Metareact** is a programming framework and a compiler that was build with the purpose of making 
decentralized programming easier. It is part of the software that will be used by [ryaki](http://ryaki.org),
 an organization that aims to build p2p productive processes, like Uber but with an emphasis on Democracy 
above all other [properties](http://ryaki-org.blogspot.gr/2015/10/it-is-about-democracy-not-economic.html).

## Automation Challenges {#Automation_Challenges}

The rise of automation and the emergence of p2p production processes has introduced new requirements 
for software both technical and ethical.

The automation of production processes with the use of computers makes it more difficult for people to understand why each production choice is made. People have to do what the program tells them to do. This is already true for companies, an employee doesn't know why he does something but automation has the potential to determine more parts of our life.
Metareact tries to alleviate this problem by requesting that all p2p automation software use free software licenses(GPL).
Secondly, its goal is to make these software easier to read. The end goal is that any person whose life is automated by software should be able to understand the software code and be able to change it. 

To achieve those goals, metareact implements the below characteristics:

* It uses [literate programming](https://en.wikipedia.org/wiki/Literate_programming). Each program is a book that contain pieces of code. The book explains the motivation behind the code.
It has a very powerful metaprgramming framework that allows for the creation of models and the generation of code from them.
* It uses visual graph representations for programming distributed applications.

## Distributed systems Cost of Developing {#Distributed_Systems_Cost}

Apart from the ethical requirements of automating p2p processes, there are technical problems as well. Writing distributed applications is very difficult. Thus it requires a considerable amount of capital for them to be built. Investors have the tendency of controlling whatever they invest on. Uber for example has created a very good p2p application but the control of that application has resulted in making a fortune while the people that work as taxi drivers earning very little. Thus, if we want to create a myriad of p2p processes that are controlled democraticly, we need to decrease the cost of building them.

To reduce the cost of Developing, metareact has te below characteristics:

* It is reactive and functional.
  * It promotes programming without side effects. Side effects, when present, are explicitly handled.
  * It promotes programming without state. If state is present, it has rules that make distributed programming safe.
Those rules are checked by the compiler.
  * The visual graph representation consists of a number of functions and their composition. There are no loops.
The graph is a series of statements and the program needs to guarantee their logical consistency.

example: 
```
f(x) = 2x
g(x) = 5 - x

f->g

```

When x = 2, f = 4, thus g must be 1, otherwise the program would be logically inconsistent.
Being similar to declarative programming, it allows for easier reasoning than imperative programming with state.

* It makes stateful distributed programming easy.
  * Metareact uses the graph visualization to define state machines. The code follows the logic of the application.
State machine code is generated by the compiler. This is the most important feature of metareact because p2p processes are stateful. 
//TODO update this when I finish implementing the reamining features.
  * It is easy to split state machines and create a hierarchy of them. That is important because p2p processes and group organizations are fractal.

* It introduces a metaprogramming framework, [protein](https://github.com/xekoukou/protein). This allows people to make abstractions of the p2p processes. It allows them to create models of them. 
  * Models compresses information about the p2p processes into the important parts and that allows people to better understand them and reason about. 
  * It allows them to create a multitude of different p2p processes using the template system of the model and thus it reduces the cost of programming.

es
//TODO Move them to another section.
Other Metareact properties:

* **Order of execution**: Because metareact is reactive and functional, the order of execution doesn't follow the sequence of the arguments. As we stated before the only thing that metareact wants to guarantee is the logical consistency of the arguments. Thus the order of execution is irrelevant. But there are cases where we order is relevant. For such cases, we need to explicitly write that the order must be preserved.
* **Lossful Computation**: There are cases in which we only care about the current value of the output of a computation and we can omit intermediary values.(ex. receiving data from sensors) In other case, we need all outputs from all data. Metareact allows for both types of computations.
* Metareact code is **implicitly concurrent** and **explicitly parallel**. With a single character, a piece of graph becomes parallelized. There is no possibility for dead locks.
* Metareact uses a **multi-level visual graph representation** that allows people to organize code thematically.

# Description {#Description}

Metareact uses graph visualizations to describe the composition of different functions, as well as to define special properties that edges and nodes of the graph have.

Some of the properties of metareact follow:

* **Order of execution**: Metareact only guarantees the logical consistency of function composition. The order of execution can not be determined beforehand.
* Metareact code is **implicitly concurrent** and **explicitly parallel**. The same function, if given two sets of arguments, can execute concurrently. Two subgraphs that do not depend to each other can executed in parallel.
* Metareact uses **multi-level visual graph representations** that allow people to organize code thematically.




## Graphs and nodes {#Graphs_and_Nodes}

Each program consists of nodes. A node can either contain code or a graph that contains nodes. We call them **code nodes** and **graph nodes** respectively. 

A graph is **directed** and **acyclic**. Each node requires all inputs to execute and produce an output, like a normal function. A node though can create side-effects. It is up to the programmer to explicitly point them. This information is propagated to the higher graph levels. The programmer will need to check whether the order of execution of certain parts of the graph are important and if necessary create a dependency so that the compiler will ensure the order of execution.

//TODO These will probably change in the future.

Nodes can have these properties:

* Parellelized: This node should be executed in a different thread.
* ?Asynchronous?: This node is the connection of the program to the outer world. It creates events that the program needs to react to. //TODO We should remove this property alltogether and have complete systems expressed in metareact.
* Ordered: This node requires that its output is ordered by the order of the input. FIFO.

Edges can have these properties:

* mutable: The output is mutable but must also abide by restrictions. The mutable variable can only be passed to only one node in a different thread.
* lossless: This output requires that it is computed for all input sent to the node.
* historical: This output depends on all previous inputs of the node. The node is ordered and the edge is also lossless.
* dependency: This output doesn't contain data. It only signifies a logical dependency between 2 parts of the graph because of side-effects.
* passive: This output doesn't propagate the execution. It waits to be used when events from other parts of the graph are triggered.


## Level functions {#Level_functions}

Each graph has also 3 types of functions that can be used by the contained nodes and recursively by all the contained nodes of the graph nodes.

* reusable functions: Functions that can be used multiple times.
* single use functions: Functions that are used only once from a code node of this graph. Since there can be no if-statements in the graph, paths express functional composition, single_use functions are used inside code nodes in if statements.
* dynamic functions: Functions that are plugged into the graph at runtime. In this way we mutate the graph at runtime.

We will all call them **level functions**.

## Hierarchical State machines {Hierarchical_State_Machines}

//TODO Implement this and rewrite this section.

State machines are used in metareact to allow for a continuation style of programming in distributed applications. The state is simply the position in the graph that computations will follow as soon as a network response is received.

* A state machine has a name that works as an unique id in the application.
* A state machine transition might allow the handling of the lower level state machine to be handled by other servers. That transition should provide a name that acts as a unique id for that handling.
* The server should be able to add servers as eligible to handle the lower state machine.
* Metareact should be able to provide an optional security mechanism that only accepts inputs that have been handled by those servers. (with a signature mechanism).


# Compiler Overview {#Compiler_Overview}

## Modularity and recursive execution. {#Modularity_and_Recursive_Execution}

Tests can be applied at each node. Because of that, the code for that node will need to be generated seperately from the main program. That forces our compilation and code generation to be modular. 

The process of joining nodes to compile graph nodes and ultimately the program is as follows:
* If a node is a code node, we find all the dependencies it has with reusable or single use functions. (TODO dynamic?). We compile them and then compile the code node.
* If a node is a graph node, we compile all containing nodes and then compile the graph node.

Please note that level functions have also level functions inside them. Also it is important to note these implementation details:
* If multiple nodes depend on one reusable function, only one compilation should happen.(check following section).
* For multiple levels of graphs to join, some requirements need to be met:
    *  All inputs need of a lower graph need to be provided by the previous graph.
    * All outputs of the higher graph need to have a corresponding node that provides that output.
* On the top level, there should be only side-effects or inputs/outputs that have been explicitly defined.

## Recompilation {#Recompilation}

At the same time we want our compiler to know which parts of the code changed and only recompile those pieces. 

There are 2 cases:

* a node changes: That node needs to be recompiled and all the graphs that recursively contain it.
* A reusable or single use function changes: All nodes that are at lower levels need to be compiled if they depend on this function. (thus we need to keep track of those dependencies). The graph that contains this function and recursively all higher graphs need to recompile , similarly to when a node changes.

Certainly, the compiler needs to keep track of changes in the nodes. Thus it needs to keep a list of time of last change of a node that was compiled and check it with the current time of last change. 

## Two steps of compilation {#Two_Steps_of_Compilation}

There are two steps in the compilation.

The first compilation has to do with generating the information required for the second step as well as provide checks that all the information is correct, that the restrictions we have put have been upheld are correct.
(Some restrictions might need the complete information from all the nodes to be checked and thus cannot be modular (?))


//TODO Find a solution.
The second process deals with generating the code based on the information provided by the first process. In this case as well, we can not be modular. There are multiple reasons for this:

* The lossless property progates backward.
* The code needed for the reactive scheduler needs to be modular. (maybe we can do this). In any case, the final step of joining all the modular parts will need to happen at the end.

# Testing {#Testing}

For testing we will use these functions:

```javascript test
function is_object(obj) {
  return obj === Object(obj);
}

function are_var_equal(var1,var2) {
  if(Array.isArray(var1) && Array.isArray(var2)) {
    return are_arrays_equal(var1,var2);
  }
  if(is_object(var1) && is_object(var2)) {
    return are_objects_equal(var1,var2);
  }
  if(!is_object(var1) && !is_object(var2)) {
    return var1 == var2;
  }
  return false;
}

function are_arrays_equal(ar1,ar2) {
  if(ar1.length != ar2.length) {
    return false;
  }
  for(var index = 0; index < ar1.length; index++) {
    var el1 = ar1[index];
    el2 = ar2[index]; 
    if(!are_var_equal(el1,el2)) {
      return false;
    }
  };
  return true;
}

function are_objects_equal(obj1,obj2) {
  var keys = Object.keys(obj1);
  for(var index = 0; index < keys.length; index++) {
    var key = keys[index];
    if(!(key in obj2)) {
      return false;
    }
    if(!are_var_equal(obj1[key],obj2[key])) {
      return false;
    }
  };
  return true;
}

function assert(var1, var2, msg) {
  if(!are_var_equal(var1,var2)) {
    throw new Error(msg);
  }
}

function debug(data) {
  process.stderr.write(JSON.stringify(data) + "\n");
}
```

# Module Dependencies {#Module_Dependencies}

//TODO this needs to be removed in the final program and put in the corrent place.

```javascript
var fs = require('fs');
var execSync = require('child_process').execSync;
```

# Generate graph xml from mr file {#Generate_Graph_xml_from_mr_file}

A graph node contains all the data about the graph in its xml file. The graph itself could be created through a nice gui or it could be provide in a simple text file with an '.mr' extension.

In both cases, the data of the graph need to be inserted into the XML file. This is the purpose of this graph node:

//TODO Explain the format of the graph tag.

```mr
./output("./temp/generate_graph_xml_from_mr_file.mr")
./dots(1)
parse_mr_file             check_node_properties   insert_graph_content_to_xml_files
     |-----------(graphs)------|-(check_node_properties_dep)---d-----|
     |----(graphs)---------------------------------------------------|
     |                   check_same_output_name                      |
     |-----------(graphs)-------|--(check_same_output_name_dep)--d---|
./dots(-1)
```

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file.xml")
./dots(1)
--%gt
%ltroot%gt
%ltinfo%gt
%ltname%gtgenerate_xml_from_mr_file%lt/name%gt
%lt/info%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

## Parse .mr file {#Parse_mr_file}

The syntax of the .mr file is as follows:

* Function names
    *  are strings without spaces that do not contain parenthesis.
    * can contain single properties which are seperated from the name with a colon ":".
    * can contain a name that represents the server type responsible for this node, seperated by a secondary ":".
* Below each function name, there is only one pipe sympol "|" and below that pipe sympol more can follow.
* A Path
    * is a series of minuses "-" that connect one pipe of a function with another, the left side representing the output of a variable and the right the input. Let us call this a *path*.
    * can go down one line with a backslash "\" and up with a forward slash "/".
    * **must** contain the name of the variable contained in parentheses.
    * can have properties that are single characters that are put together and do not have parentheses.

In this graph node, we will parse the .mr file and we will create a  graph object of its data.

```mr
./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file.mr")
./dots(1)
load_mr_file find_function_names              find_end_points              path_traversal        build_graph
  |          |-----------(function_names)-------|--------(end_points)---------|-------(gpaths)----|
  |          |------------(function_names)--------------------------------------------------------|
  |-(lines)--|                           find_end_points                    
  |-(lines)-------------------------------------|                         path_traversal
  |-(lines)-------------------------------------------------------------------|
./dots(-1)
```

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file.xml")
./dots(1)
--%gt
%ltroot%gt
%ltinfo%gt
%ltname%gtparse_mr_file%lt/name%gt
%lt/info%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

## load mr file {#load_mr_file}

It loads the mr_file and splits it into lines.

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/load_mr_file.xml")
./dots(1)
--%gt
%ltroot%gt
%ltinfo%gt
%ltname%gt load_mr_file%lt/name%gt
%lt/info%gt
%ltinputs%gt
%ltinput name="mr_file" side-effect="true"%gt
    %ltdescription%gtIt is provided the mr file of the mr_file_path.%lt/description%gt
%lt/input%gt
%ltinput name="mr_file_path"%gt
%lt/input%gt
%lt/inputs%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

```javascript
//.dots(-1)("./temp/generate_graph_xml_from_mr_file/parse_mr_file/load_mr_file.js")
//./dots(1)
function load_mr_file(file_path) {
var lines;
////
var file = fs.readFileSync(file_path,"utf8");
lines = file.split("\n");
////
return lines;  
}
//.dots(-1)
```

```javascript test
assert(load_mr_file("./tests/generate_graph_xml_from_mr_file/parse_mr_file/load_mr_file/1.mr"), ["line1","line2",""],"load_mr_file 1 test Failed");
```

## Find function names {#Find_function_names}

Returns the function names of the nodes and their position inside the mr file.

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names.xml")
./dots(1)
--%gt
%ltroot%gt
%ltinfo%gt
%ltname%gt find_function_names %lt/name%gt
%lt/info%gt
%ltinputs%gt
%ltinput name="mr_file_path"/%gt
%lt/inputs%gt
%ltoutputs%gt
%ltoutput name="wrong_node_property" side-effect="true"%gt
    %ltdescription%gt It returns an error when a node has been given a property that doesn't exist. The side effect is that the application exits.%lt/description%gt
%lt/output%gt
%lt/outputs%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

```javascript
//./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names.js")
//./dots(1)

function find_function_names(lines,mr_file_path) {
var function_names;
////////////////////////
function_names = [];

var y = 0;
while (y < lines.length) {
var x = 0;
var line = lines[y];
while (x < line.length) {
    var xar = line.charAt(x);
    //find all non whitespace strings
    if (xar != " ") {
	var string = line.substring(x).split(" ", 1)[0];
	//check that they only have alphanumeric or _ characters
	var alphanum = string.match(/^[a-z_:0-9]+$/i);
	if (alphanum) {
	    var value = alphanum[0].split(":", 2);
	    var function_name = {
		x: x,
		y: y,
		fn_name: value[0],
		properties: {}
	    };
	    if (value.length > 1) {
		for (var i = 0; i < value[1].length; i++) {
		    var xar = value[1].charAt(i);
                    switch (xar) {
                      case "c": {
			function_name.properties.concurrent = true;
                        break;
                      }
                      case "a": {
		        function_name.properties.asynchronous = true;
                        break;
                      }
                      case "o": {
		        function_name.properties.ordered = true;
                        break;
                      }
                      default: {
	        	debug("Error: There is no option '" + xar + "' for a function");
			debug("File: " + mr_file_path);
			debug("Function Name: " + value[0]);
			process.exit(1);
                      }
                    }
		}
	    }
	    //store them
	    function_names.push(function_name);
	}
	x = x + string.length - 1;
    }
    x++;
}
y++;
}
return function_names;
}
//./dots(-1)
```

```javascript test
assert(find_function_names(load_mr_file("./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names/1.mr"),"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names/1.mr"), [{'fn_name':'hello','x':0,'y':0,properties:{'concurrent':true,'asynchronous':true}},{'fn_name':'world','x':18,'y':0,properties:{}},{'fn_name':'Hi','x':0,'y':3,properties:{'concurrent':true}},{'fn_name':'there','x':11,'y':3,properties:{'concurrent':true,'asynchronous':true,'ordered':true}}],"find function_names 1 test Failed");

assert(find_function_names(load_mr_file("./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names/2.mr"),"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_function_names/2.mr"),"error 1","find_function_names 2 test Failed");
```

## Find end points {#Find_end_points}

It returns the position of all the end_points with the function they belong to. 

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points.xml")
./dots(1)
--%gt
%ltroot%gt
    %ltinfo%gt
        %ltname%gt find_end_points %lt/name%gt
    %lt/info%gt
    %ltinputs%gt
        %ltinput name="mr_file_path"/%gt
    %lt/inputs%gt
    %ltoutputs%gt
    %lt/outputs%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

```javascript
//./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points.js")
//./dots(1)
function find_end_points(lines, function_names, mr_file_path) {
    var end_points;
    ////////////////////
    end_points = {};

for(var i = 0; i < function_names.length; i++) {
    var fn = function_names[i];

    if (fn.y + 1 == lines.length) {
      debug("Error: There is a function that isn't connected to another function.");
      debug("File: " + mr_file_path);
      debug("Function Name: " + fn.fn_name);
      process.exit(2);
    }

    var y = fn.y + 1;
    var line = lines[y];
    var x = fn.x;
    var once = 0;
    while ((x < fn.x + fn.fn_name.length) && (x < line.length)) {
        var xar = line.charAt(x);

        if (xar == "|") {
            if (!end_points[y]) {
                end_points[y] = {};
            }
            end_points[y][x] =
                fn.fn_name;

            y++;
            if (y >= lines.length) {
                break;
            }
            line = lines[y];
            var once = 1;

        } else {
            if (once) {
                break;
            }
            x++;
        }
    }

    if (once == 0) {
      debug("Error: There is a function that isn't connected to another function.");
      debug("File: " + mr_file_path);
      debug("Function Name: " + fn.fn_name);
      process.exit(3);
    }

};

//./dots(-1)
  return end_points;
}
```

```javascript test
var test_lines = load_mr_file("./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/1.mr");
assert(find_end_points(test_lines, find_function_names(test_lines,"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/1.mr"),"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/1.mr"), {'1':{'2':'hello','18':'world'},'4':{'0':'Hi','12':'there'}},"find end points test 1 Failed");

var test_lines = load_mr_file("./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/2.mr");
assert(find_end_points(test_lines, find_function_names(test_lines,"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/2.mr"),"./tests/generate_graph_xml_from_mr_file/parse_mr_file/find_end_points/2.mr"), "error 3","find end points test 2 Failed");
```


## Path finding {#Path_finding}

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file/path_finding.xml")
./dots(1)
--%gt
%ltroot%gt
    %ltinfo%gt
        %ltname%gt path_traversal %lt/name%gt
        %ltdescription%gt It finds all the paths of the graphs. %lt/description%gt
    %lt/info%gt
    %ltinputs%gt
        %ltinput name="srcodes"/%gt
        %ltinput name="mr_file_paths"/%gt
        
    %ltinput generated="true" name="end_points"/%gt%lt/inputs%gt
    %ltoutputs%gt
        
    %ltoutput generated="true" name="gpaths"/%gt%lt/outputs%gt
%lt/root%gt
```

       </div>
    </div>
</body>
</html>
