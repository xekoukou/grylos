<!DOCTYPE html>
<html>
<head>
<title>Metareact</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script src="Markdown.Converter.js"></script>
<script src="Markdown.Extra.js"></script>
<script src="jquery-2.1.4.min.js"></script>
<link rel="stylesheet" href="highlight/styles/default.css">
<script src="highlight/highlight.pack.js"></script>
<script src="MathJax-master/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="markdown.js"></script>
<link rel="stylesheet" href="pure-min.css">
<link rel="stylesheet" href="markdown.css">
</head>
<body>
    <div style = "font-size:115%">
       <div class="markdown">
_

# Table of Contents

## Introduction 

**Metareact** is a programming framework and a compiler that was build with the purpose of making 
decentralized programming easier. It is part of the software that will be used by [ryaki](http://ryaki.org),
 an organization that aims to build p2p productive processes, like Uber, but with an emphasis on Democracy 
above all other [properties](http://ryaki-org.blogspot.gr/2015/10/it-is-about-democracy-not-economic.html).

The rise of automation and the emergence of p2p production processes has introduced new requirements 
for software both technical and ethical.

The automation of production processes by computers makes it more difficult for people to understand the reasons behind the choices of the computer. People have to do what the program tells them to do. This already happens inside companies where each employer doesn't know why he does something. If automation claims more parts of our lifes, things will get worse.
Metareact tries to alleviate this problem by requesting that all p2p automation software use free software licenses(GPL) and by making these software easier to read. The end goal is that any person whose life is automated by software should be able to understand the software code and be able to change it. Metareact is build with this on mind:

1. It uses [literate programming](https://en.wikipedia.org/wiki/Literate_programming). Each program is a book that contain pieces of code. The book explains the motivation behind the code.
2. It uses visual graph representations as the form of programming distributed applications that make them much easier to read and understand. 

Apart from the ethical requirements of automating p2p processes, there are technical problems as well. Writing distributed applications is very difficult. Thus it requires a considerable amount of capital for them to be built. Investors have the tendency of controlling whatever they invest on. Uber for example has created a very good p2p application but the control of that application has resulted in making a fortune while the people that work as taxi drivers earning very little. Thus, if we want to create a myriad of p2p processes that are democratic, we need to decrease the cost of building them.
In what way does metareact help in simplifying the development of distributed applications?

* It is reactive and functional.
  * Side effects either do not exist or are explicitly handled.
  * There either has no shared mutable state or that state must follow rules that make it safe. 
Those rules are checked by the compiler.
  * The visual graph representation consists of a number of functions and their composition. There are no loops.
The graph can be read as a series of statements and the program needs to guarantee their logical consistency.

ex. pseudocode:
```
f(x) = 2x
g(x) = 5 - x

f->g

function j(x) {

var g = 0;

return 5;
}

```

When x = 2, f = 4, thus g must be 1, otherwise the program would be logically inconsistent.
Being similar to declarative programming, it allows for easier reasoning than imperative programming with mutable state.

* It makes statefull distributed programming easy.
  * Metareact uses the graph visualization to define finite state machines. The code follows the logic of the application.
Finite state machine code is generated by the compiler. This is the most important feature of metareact because p2p processes are statefull. 
  * It is easy to split finite state machines and create a hierarchy of them. That is important because p2p processes and group organizations are fractal.

* It introduces a metaprogramming framework, [protein](https://github.com/xekoukou/protein). This allows people to make abstractions of the p2p processes. It allows them to create models of them. 
  * Models compresses information about the p2p processes into the important parts and that allows people to better understand them and reason about. 
  * It allows them to create a multitude of different p2p processes using the template system of the model and thus it reduces the cost of programming.

Other Metareact properties:

* **Order of execution**: Because metareact is reactive and functional, the order of execution doesn't follow the sequence of the arguments. As we stated before the only thing that metareact wants to guarantee is the logical consistency of the arguments. Thus the order of execution is irrelevant. But there are cases where we order is relevant. For such cases, we need to explicitly write that the order must be preserved.
* **Lossful Computation**: There are cases in which we only care about the current value of the output of a computation and we can omit intermediary values.(ex. receiving data from sensors) In other case, we need all outputs from all data. Metareact allows for both types of computations.
* Metareact code is **implicitly concurrent** and **explicitly parallel**. With a single character, a piece of graph becomes parallelized. There is no possibility for dead locks.
* Metareact uses a **multi-level visual graph representation** that allows people to organize code thematically.

## Definitions

### Graphs and nodes

Each program consists of nodes. A node can either contain code or a graph that contains nodes. We call them **code nodes** and **graph nodes** (or just graph) respectively. 

A graph is directed and acyclic. Each node requires all inputs to execute and produce an output. Thus it can be thought of as a function composition. A node though can create side-effects. It is up to the programmer to explicitly point them. This information is propagated to the higher graph levels. The programmer will need to check whether the order of execution of certain parts of the graph are important and if necessary create a dependency so that the compiler will ensure the order of execution.

//TODO These will probably change in the future.

Nodes can have above properties:

* Concurrent: This node should be executed in a different thread.
* ?Asynchronous?: This node is the connection of the program to the outer world. It creates events that the program needs to react to.
* Ordered: This node requires that its output is ordered by the order of the input. FIFO.

Edges can have the above properties:

* mutable: The output is mutable but must also abide by restrictions. The mutable variable can only be passed to only one node in a different thread.
* lossless: This output requires that it is computed for all input sent to the node.
* historical: This output depends on all previous inputs of the node. The node is ordered and the edge is also lossless.
* dependency: This output doesn't contain data. It only signifies a logical dependency between 2 parts of the graph because of side-effects.
* passive: This output doesn't propagate the execution. It waits to be used when events from other parts of the graph are triggered.


### Level functions

Each graph has also 3 types of functions that can be used by the contained nodes and recursively by all the contained nodes of the graph nodes.

* reusable functions: Functions that can be used multiple times.
* single use functions: Functions that are used only once from a code node of this graph. Since there can be no if-statements in the graph, paths express functional composition, single_use functions are used inside code nodes in if statements.
* dynamic functions: Functions that are plugged into the graph at runtime. In this way we mutate the graph at runtime.

We will all call them **level functions**.

## Compiler Overview

### Modularity and recursive execution.

Tests can be applied at each node. Because of that, the code for that node will need to be generated seperately from the main program. That forces our compilation and code generation to be modular. 

The process of joining nodes to compile graph nodes and ultimately the program is as follows:
* If a node is a code node, we find all the dependencies it has with reusable or single use functions. (TODO dynamic?). We compile them and then compile the code node.
* If a node is a graph node, we compile all containing nodes and then compile the graph node.

Please note that level functions have also level functions inside them. Also it is important to note these implementation details:
* If multiple nodes depend on one reusable function, only one compilation should happen.(check following section).
* For multiple levels of graphs to join, some requirements need to be met:
    *  All inputs need of a lower graph need to be provided by the previous graph.
    * All outputs of the higher graph need to have a corresponding node that provides that output.
* On the top level, there should be only side-effects or inputs/outputs that have been explicitly defined.

### Recompilation

At the same time we want our compiler to know which parts of the code changed and only recompile those pieces. 

There are 2 cases:

* a node changes: That node needs to be recompiled and all the graphs that recursively contain it.
* A reusable or single use function changes: All nodes that are at lower levels need to be compiled if they depend on this function. (thus we need to keep track of those dependencies). The graph that contains this function and recursively all higher graphs need to recompile , similarly to when a node changes.

Certainly, the compiler needs to keep track of changes in the nodes. Thus it needs to keep a list of time of last change of a node that was compiled and check it with the current time of last change. 

### Two steps of compilation

There are two steps in the compilation.

The first compilation has to do with generating the information required for the second step as well as provide checks that all the information is correct, that the restrictions we have put have been upheld are correct.
(Some restrictions might need the complete information from all the nodes to be checked and thus cannot be modular (?))


//TODO Find a solution.
The second process deals with generating the code based on the information provided by the first process. In this case as well, we can not be modular. There are multiple reasons for this:

* The lossless property progates backward.
* The code needed for the reactive scheduler needs to be modular. (maybe we can do this). In any case, the final step of joining all the modular parts will need to happen at the end.

## Testing

For testing we will use this assert function:

```javascript
function assert(var1, var2, msg) {
  if(var1 != var2) {
    throw new Error(msg);
  }
}
```

## Module Dependencies

```javascript
var fs = require('fs');
var execSync = require('child_process').execSync;
```

## Generate graph xml from mr file

A graph node contains all the data about the graph in its xml file. The graph itself could be created through a nice gui or it could be provide in a simple text file with an '.mr' extension.

In both cases, the data of the graph need to be inserted into the XML file. This is the purpose of this graph node:

```mr
./output("./temp/generate_graph_xml_from_mr_file.mr")
./dots(1)
load_mr_file               parse_mr_file
    |------(srcodes)---------|

parse_mr_file             check_node_properties   insert_graph_content_to_xml_files
     |-----------(graphs)------|-(check_node_properties_dep)---d-----|
     |----(graphs)---------------------------------------------------|
     |                   check_same_output_name                      |
     |-----------(graphs)-------|--(check_same_output_name_dep)--d---|
./dots(-1)
```

### load mr file

```xml
%lt?xml version="1.0"?%gt
%lt!--./output("./temp/generate_graph_xml_from_mr_file.xml")
./dots(1)
--%gt
%ltroot%gt
    %ltinfo%gt
        %ltname%gt load_mr_file%lt/name%gt
        %ltdescription%gt It loads the mr_file and splits it into lines. %lt/description%gt
    %lt/info%gt
    %ltinputs%gt
        %ltinput name="mr_file" side-effect="true"%gt
            %ltdescription%gtIt is provided all the mr files of the source_path directory and its subdirectories.%lt/description%gt
        %lt/input%gt
    %lt/inputs%gt
    %ltoutputs%gt
    %lt/outputs%gt
%lt/root%gt
%lt!--
./dots(-1)
--%gt
```

```javascript
//.dots(-1)("./temp/generate_graph_xml_from_mr_file/load_mr_file.js")
//./dots(1)
function load_mr_file(file_path) {
  var lines;
////
  var file = fs.readFileSync(file_path,"utf8");
  lines = file.split("\n");
////
  return lines;  
}
//.dots(-1)
```

```javascript test
assert(load_mr_file("./tests/generate_graph_xml_from_mr_file/load_mr_file/1.mr"), ["line1","line2"],"load_mr_file 1 test Failed");

```

### Parse .mr file.

The syntax of the .mr file is as follows:

* Function name are strings without spaces that do not contain parenthesis.
* Function names can contain single properties which are seperated from the name with a colon ":".
* Below each function name, there is only one pipe sympol "|" and below that pipe sympol more can follow.
* A series of minuses "-" connect one pipe of a function with another, the left side representing the output of a variable and the right the input. Let us call this a *path*.
* A path can go down one line with a backslash "\" and up with a forward slash "/".
* A path *must* contain the name of the variable contained in parentheses.
* A path can have properties that are single characters that are put together and do not have parentheses.

```mr
./output("./temp/generate_graph_xml_from_mr_file/parse_mr_file.mr")
./dots(1)
find_functions                   find_end_points              path_traversal        build_graph
   |-----------(function_names)-------|--------(end_points)---------|-------(gpaths)----|
   |------------(function_names)--------------------------------------------------------|
./dots(-1)
```

```xml

```







       </div>
    </div>
</body>
</html>
